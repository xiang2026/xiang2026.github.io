{"title":"为博客添加AC娘表情包","slug":"为博客添加AC娘表情包","date":"2019-08-03T04:49:25.000Z","updated":"2019-08-03T08:49:19.538Z","comments":true,"path":"api/articles/为博客添加AC娘表情包.json","photos":[],"link":"","excerpt":" [Figure] }最终效果基本就如本文展示的效果。从原理上来说，本贴的实现方法适用于任何基于图片的表情包。下面来详细说说实现方法。","covers":["/2019/08/03/为博客添加AC娘表情包/title.jpg","/2019/08/03/为博客添加AC娘表情包/../public/static/ac_sticker/51.gif","/2019/08/03/为博客添加AC娘表情包/02.jpg","/2019/08/03/为博客添加AC娘表情包/03.jpg","/2019/08/03/为博客添加AC娘表情包/04.jpg","/2019/08/03/为博客添加AC娘表情包/../public/static/ac_sticker/01.gif","/2019/08/03/为博客添加AC娘表情包/../public/static/ac_sticker/15.gif"],"content":"<p><img src=\"/2019/08/03/为博客添加AC娘表情包/title.jpg\" alt></p>\n<p>闲来无事<del>（不想做手头没做完的任务）</del>，于是想继续折腾折腾这个博客，记得最初看Hexo相关的帖子的时候有人为博客添加了emoji表情的支持，还写了相关的插件。于是心血来潮想给自己的Hexo增加一套自定义表情，作为猴山一员，AC娘表情当然首当其冲成为选择。<img style=\"display:inline-block;vertical-align:-30px\" src=\"/static/ac_sticker/51.gif\" alt></p>\n<p>最终效果基本就如本文展示的效果。从原理上来说，本贴的实现方法适用于任何基于图片的表情包。下面来详细说说实现方法。</p>\n<a id=\"more\"></a>\n<h2 id=\"为Hexo添加表情包的基本原理\"><a href=\"#为Hexo添加表情包的基本原理\" class=\"headerlink\" title=\"为Hexo添加表情包的基本原理\"></a>为Hexo添加表情包的基本原理</h2><p>对于Hexo来说，表情包图片和普通图片是一样的。因此最简单的方法，我们可以直接往文章中插入表情包图片来实现这一功能。因此我直接在git上找了一套<a href=\"https://github.com/sljeff/new_acfun\" target=\"_blank\" rel=\"noopener\">AC娘的表情包</a>，写了一个简单的测试Markdown文件进行测试。但是由于一般情况下，Hexo的主题模板是不会区分你插入的这些新图片的，因此渲染得到的文章会呈现这样的惨状。</p>\n<p><img src=\"/2019/08/03/为博客添加AC娘表情包/02.jpg\" alt></p>\n<p>可以看到，由于图片的统一渲染方式，增加的表情包被当成普通图片，处理成了块元素，而不是我们所希望的行内元素。</p>\n<p>因此我们需要修改一下主题生成静态文件的流程。使之可以区分出插入的表情包文件，并在生成页面时添加表情图片的特殊样式，使之可以显示为行内元素。</p>\n<h2 id=\"Lite主题的页面生成过程\"><a href=\"#Lite主题的页面生成过程\" class=\"headerlink\" title=\"Lite主题的页面生成过程\"></a>Lite主题的页面生成过程</h2><p>在真正开始处理之前，我们需要了解下Hexo的页面生成流程。一般来说，Hexo的页面生成流程有以下几个步骤。</p>\n<ul>\n<li>Markdown文件解析与渲染</li>\n<li>中间数据处理（可选）</li>\n<li>根据数据填充主题模板，生成静态网站页面。</li>\n</ul>\n<p>Hexo默认使用marked.js进行markdown文件的解析。在文件解析这一步中，存放在_post目录下的markdown文件被读入，并根据规则生成html结构的字符流。举个例子，一行形如“# markdown”的文字会被解析处理成如下的形式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span> markdown <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>同样的，按照markdown格式插入的图片会被处理成img标签。之后，Hexo会将所有数据包装成site，来表示一个站点。传递给主题进行处理和最终渲染。</p>\n<p>在主题中，可以对传入的数据进行处理，比如增加样式等。然后使用数据填充模板，生成静态文件页面。因此我们只需在模板处理中间数据的时候将自己添加的表情包文件标签过滤出来，添加上行内样式即可。</p>\n<p>Hexo提供了丰富多样的主题，也有很多人自己开发，这其中不乏有强大配置功能的主题，可以对数据进行中间处理配置，如定义样式等。这样根据主题的文档，设置具体的样式就可以解决上面的问题。我目前使用的是一个名为Lite的主题，我非常喜欢他的风格，但是这个主题没有多少可配置的选项。因此要实现数据中间结果处理，必须修改原有的页面生成代码。</p>\n<p>Hexo提供了<a href=\"https://hexo.io/zh-cn/api/generator.html\" target=\"_blank\" rel=\"noopener\">生成器API</a>来处理页面路由的生成逻辑，Lite主题也是使用这一接口进行静态页面路由的生成。在主题的scripts文件夹下可以找到generate-api.js文件，文件大致如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用自身定义的generator方法进行数据处理，返回处理后的数据</span></span><br><span class=\"line\">hexo.extend.generator.register(<span class=\"string\">'liteRestfulApi'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">site</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> generator(<span class=\"built_in\">Object</span>.assign(&#123;&#125;, hexo.config, &#123;</span><br><span class=\"line\">    theme_config: hexo.theme.config</span><br><span class=\"line\">  &#125;), site);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>generate方法根据传入的站点设置和主题设置，以及site数据，进行分页和页面数据转换处理，并生成对应页面的路由。其中页面相关的代码如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成文章页面路由</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (restful.post) &#123;</span><br><span class=\"line\">    apiData = apiData.concat(posts.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> path = <span class=\"string\">'api/articles/'</span> + post.slug + <span class=\"string\">'.json'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        path: path,</span><br><span class=\"line\">        data: <span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 省略其他数据处理， content为html格式的文章正文</span></span><br><span class=\"line\">          content: post.content,</span><br><span class=\"line\">          <span class=\"comment\">// ...         </span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成首页文章card</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (restful.posts_size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> page_posts = [],</span><br><span class=\"line\">          len = postlist.length,</span><br><span class=\"line\">          ps = restful.posts_size,</span><br><span class=\"line\">          pc = <span class=\"built_in\">Math</span>.ceil(len / ps);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i += ps) &#123;</span><br><span class=\"line\">        page_posts.push(&#123;</span><br><span class=\"line\">            path: <span class=\"string\">'api/posts/'</span> + <span class=\"built_in\">Math</span>.ceil((i + <span class=\"number\">1</span>) / ps) + <span class=\"string\">'.json'</span>,</span><br><span class=\"line\">            data: <span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">                total: len,</span><br><span class=\"line\">                pageSize: ps,</span><br><span class=\"line\">                pageCount: pc,</span><br><span class=\"line\">                <span class=\"comment\">// 首页某个页面上的所有文章card的正文数据，html格式</span></span><br><span class=\"line\">                data: postlist.slice(i, i + ps).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>)</span>&#123;</span><br><span class=\"line\">                    post.content = post.content</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> post;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p>可以看到和文章内容相关的有两处，一处是文章正文的生成，一处是首页文章card页面的生成。每一个对应的结构返回了文章的路由路径和文章数据，后续数据会被根据模板进行填充，最终生成静态页面。因此我们可以在数据返回前对数据进行处理，实现我们所需的样式和功能。</p>\n<h2 id=\"自定义结构并进行处理\"><a href=\"#自定义结构并进行处理\" class=\"headerlink\" title=\"自定义结构并进行处理\"></a>自定义结构并进行处理</h2><p>了解了整个Hexo配合主题生成页面的流程之后，我们就可以修改代码实现功能了。我们可以定义一个特殊的书写结构，表明这个文本串是一个表情包，之后在生成页面路由数据的时候，将这些串通过正则表达式匹配出来进行替换，得到增加了行内样式的html标签代码，这样就可以使页面正确显示了。</p>\n<p>在此之上，我还希望能够提升我写博客的体验，能够可视化的插入表情包，而不是像emoji插件那样用字符代替。Hexo使用Markdown作为数据输入源，因此可视化的Typora就成为了首选，为了使书写过程中页面变化不至于太大，因此最终选择如下格式插入表情包：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;![<span class=\"string\">name</span>](<span class=\"link\">path</span>)&#125;</span><br></pre></td></tr></table></figure>\n<p>即在原本的格式外面新加一对大括号，这样在编辑过程中并不至于太过突兀，Typora下的效果大致如下：</p>\n<p><img src=\"/2019/08/03/为博客添加AC娘表情包/03.jpg\" alt></p>\n<p>之后，为处理对应的格式编写相应的代码。上述表情包的字符在markdown处理完成传递给生成器api时大概长以下这个样子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">(path)</span> <span class=\"attr\">alt</span>&gt;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>我们需要编写代码过滤所有这样的串，并为其添加行内样式。首先写处理逻辑，新增insertStyle方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertStyle</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rex = <span class=\"regexp\">/&#123;&lt;img[^&gt;]+src=\"?([^\"\\s]+gif)\"(.*?)&gt;&#125;/g</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> match;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((match = rex.exec(str)) != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> imgTag = <span class=\"string\">\"&lt;img style=\\\"display:inline-block;vertical-align:-30px\\\" src=\\\"\"</span> + match[<span class=\"number\">1</span>] + <span class=\"string\">\"\\\" alt&gt;\"</span>;</span><br><span class=\"line\">    str = str.replace(match[<span class=\"number\">0</span>], imgTag);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>insertStyle使用正则表达式过滤所有满足上述html串的子串，由于我使用的AC娘表情包是gif格式的，因此我将此处的过滤条件也做了限定，即满足上述html串的，同时图片格式为gif的字串。匹配到串之后将串进行替换，增加行内样式。</p>\n<p>之后修改生成文章页和首页路由的函数，将正文返回前进行过滤处理即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (restful.post) &#123;</span><br><span class=\"line\">    apiData = apiData.concat(posts.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> path = <span class=\"string\">'api/articles/'</span> + post.slug + <span class=\"string\">'.json'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        path: path,</span><br><span class=\"line\">        data: <span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 省略其他数据处理， content为html格式的文章正文</span></span><br><span class=\"line\">          content: insertStyle(post.content),</span><br><span class=\"line\">          <span class=\"comment\">// ...         </span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 首页处理同理</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h2><p>清理之前的生成，并重新生成静态文章。访问页面可以发现已经完美支持插入的表情图片。</p>\n<p><img src=\"/2019/08/03/为博客添加AC娘表情包/04.jpg\" alt></p>\n<p>完事，收工~~<img style=\"display:inline-block;vertical-align:-30px\" src=\"/static/ac_sticker/01.gif\" alt></p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>至此，已经可以比较舒服的在写作中可视化插入表情包并在文章中正确渲染了。我总结了下整个流程，觉得还有以下几点可以再进一步处理，使之更加完美。</p>\n<ul>\n<li>公用资源：当前的表情包插入和普通文件一样，也需要将表情包图片存入文章同名的文件夹内，这样会导致多个文章使用同一张表情时资源重复，希望可以再static文件夹下建立一个公用表情包文件目录，文章对图片的引用放在一起。当然最简单的是像emoji那样有个Restful的API可以获取。</li>\n<li>样式外提：写分离的css文件控制表情包的样式，不知道为啥我修改主题的scss文件总是不生效。</li>\n<li>样式修改提前：目前的实现中，样式的修改是已经在生成了html字符之后再去修改的，由于无法修改markdown的解析过程，无奈将修改放在了页面渲染部流程中。可以通过修改Hexo的markdown渲染插件为markdown-it，自定义渲染规则直接生成带有class或者样式的表情包img标签，从流程上来说更为正确优雅。</li>\n<li>插件化&amp;&amp;配置化：通过插件+配置的形式而不是直接改代码实现表情包。</li>\n<li>替换Hexo：折腾了一周发现更想折腾了，而且在折腾中又发现当前这个主题无法适配edge。<img style=\"display:inline-block;vertical-align:-30px\" src=\"/static/ac_sticker/15.gif\" alt>因此产生了想灭门Hexo入Gatsby的想法。看来后续又是一堆的折腾了，233。<img style=\"display:inline-block;vertical-align:-30px\" src=\"/static/ac_sticker/38.gif\" alt></li>\n</ul>\n<p>Horo.C</p>\n","categories":[],"tags":[{"name":"建站","slug":"建站","count":3,"path":"api/tags/建站.json"},{"name":"博客","slug":"博客","count":1,"path":"api/tags/博客.json"}]}